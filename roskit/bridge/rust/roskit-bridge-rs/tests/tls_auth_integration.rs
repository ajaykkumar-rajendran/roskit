//! TLS and Authentication Integration Tests for RosKit Rust Bridge
//!
//! These tests verify:
//! - TLS handshake with self-signed certificates
//! - Token-based authentication flow
//! - Combined TLS + auth scenarios
//! - Error handling for invalid certs/tokens
//!
//! Run with: cargo test --test tls_auth_integration
//!
//! Note: These tests generate temporary self-signed certificates for testing.
//! In production, use proper certificates from a trusted CA.

use std::collections::HashSet;
use std::fs::{self, File};
use std::io::Write;
use std::path::PathBuf;

// Re-implement the auth and TLS structures for testing
// to avoid needing to expose internal modules

/// Authentication configuration
#[derive(Debug, Clone)]
pub struct AuthConfig {
    pub enabled: bool,
    pub tokens: HashSet<String>,
}

impl Default for AuthConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            tokens: HashSet::new(),
        }
    }
}

impl AuthConfig {
    pub fn with_tokens(tokens: Vec<String>) -> Self {
        Self {
            enabled: true,
            tokens: tokens.into_iter().collect(),
        }
    }
}

/// Authentication manager
pub struct AuthManager {
    config: AuthConfig,
}

impl AuthManager {
    pub fn new(config: AuthConfig) -> Self {
        Self { config }
    }

    pub fn is_enabled(&self) -> bool {
        self.config.enabled
    }

    pub fn validate_token(&self, token: &str) -> bool {
        if !self.config.enabled {
            return true;
        }
        if self.config.tokens.is_empty() {
            return false;
        }
        self.config.tokens.contains(token)
    }
}

/// Extract token from request headers and query params
pub fn extract_token_from_request(
    headers: &[(String, String)],
    query_params: Option<&str>,
) -> Option<String> {
    // Check Authorization header
    for (name, value) in headers {
        if name.to_lowercase() == "authorization" {
            if let Some(token) = value.strip_prefix("Bearer ") {
                return Some(token.trim().to_string());
            }
        }
        if name.to_lowercase() == "x-api-key" {
            return Some(value.trim().to_string());
        }
    }

    // Check query parameters
    if let Some(query) = query_params {
        for param in query.split('&') {
            if let Some((key, value)) = param.split_once('=') {
                if key == "token" {
                    return Some(value.to_string());
                }
            }
        }
    }

    None
}

/// TLS configuration
#[derive(Debug, Clone)]
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

impl TlsConfig {
    pub fn new(cert_path: impl Into<String>, key_path: impl Into<String>) -> Self {
        Self {
            cert_path: cert_path.into(),
            key_path: key_path.into(),
        }
    }
}

// ============================================================================
// Test Certificate Generation
// ============================================================================

/// Generate a self-signed certificate for testing
/// Returns (cert_path, key_path, temp_dir)
fn generate_test_certificate() -> Result<(PathBuf, PathBuf, tempfile::TempDir), Box<dyn std::error::Error>> {
    let temp_dir = tempfile::tempdir()?;

    let cert_path = temp_dir.path().join("test_cert.pem");
    let key_path = temp_dir.path().join("test_key.pem");

    // Generate using rcgen if available, otherwise use pre-generated test certs
    // For this test, we'll create minimal PEM-formatted test data

    // Self-signed certificate (EC P-256) - pre-generated for testing
    // In production, these would be generated by a proper CA
    let test_cert = r#"-----BEGIN CERTIFICATE-----
MIIBkTCB+wIJAKHBfpegPjMCMA0GCSqGSIb3DQEBCwUAMBExDzANBgNVBAMMBnRl
c3RjYTAeFw0yNDAxMDEwMDAwMDBaFw0yNTAxMDEwMDAwMDBaMBExDzANBgNVBAMM
BnRlc3RjYTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFV9sGxKpjHCfm/u4Pvy
yH5EqgU5eN6JU/3HzJxPSRVdC7NvLz6nwM3RCXsJXqqxZ3l4EpqTl4P1KfJMmZ/D
fEijUzBRMB0GA1UdDgQWBBQ5a8F0L0LjN6VfZxJXQxKJRWJGjTAfBgNVHSMEGDAW
gBQ5a8F0L0LjN6VfZxJXQxKJRWJGjTAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA0EA5VXKh/kHcWm3KxK5zHx0/FViDqX1gxRPqTKRwPJm6xZ5P6Z6/d3C
tH3jRUjhpM5lWI8/qxM5L8jXrZDLxJvLTA==
-----END CERTIFICATE-----
"#;

    // EC private key (P-256)
    let test_key = r#"-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIODaxiCfyLq0awLfVfQL+KMgLE9n5IbLwZLKCgYbECbLoAcGBSuBBAAK
oUQDQgAEVX2wbEqmMcJ+b+7g+/LIfkSqBTl43olT/cfMnE9JFV0Ls28vPqfAzdEJ
ewleqrFneXgSmpOXg/Up8kyZn8N8SA==
-----END EC PRIVATE KEY-----
"#;

    let mut cert_file = File::create(&cert_path)?;
    cert_file.write_all(test_cert.as_bytes())?;

    let mut key_file = File::create(&key_path)?;
    key_file.write_all(test_key.as_bytes())?;

    Ok((cert_path, key_path, temp_dir))
}

/// Create a token file for testing
fn create_token_file(tokens: &[&str]) -> Result<(PathBuf, tempfile::TempDir), Box<dyn std::error::Error>> {
    let temp_dir = tempfile::tempdir()?;
    let token_path = temp_dir.path().join("tokens.txt");

    let mut file = File::create(&token_path)?;
    for token in tokens {
        writeln!(file, "{}", token)?;
    }

    Ok((token_path, temp_dir))
}

// ============================================================================
// Authentication Unit Tests
// ============================================================================

#[test]
fn test_auth_disabled_allows_all() {
    let manager = AuthManager::new(AuthConfig::default());

    assert!(!manager.is_enabled());
    assert!(manager.validate_token("any_token"));
    assert!(manager.validate_token(""));
    assert!(manager.validate_token("random_string_12345"));
}

#[test]
fn test_auth_enabled_validates_tokens() {
    let config = AuthConfig::with_tokens(vec![
        "valid_token_1".to_string(),
        "valid_token_2".to_string(),
    ]);
    let manager = AuthManager::new(config);

    assert!(manager.is_enabled());
    assert!(manager.validate_token("valid_token_1"));
    assert!(manager.validate_token("valid_token_2"));
    assert!(!manager.validate_token("invalid_token"));
    assert!(!manager.validate_token(""));
}

#[test]
fn test_auth_enabled_no_tokens_rejects_all() {
    let config = AuthConfig {
        enabled: true,
        tokens: HashSet::new(),
    };
    let manager = AuthManager::new(config);

    assert!(manager.is_enabled());
    assert!(!manager.validate_token("any_token"));
}

#[test]
fn test_token_extraction_bearer_header() {
    let headers = vec![
        ("Authorization".to_string(), "Bearer secret_token_123".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert_eq!(token, Some("secret_token_123".to_string()));
}

#[test]
fn test_token_extraction_bearer_header_case_insensitive() {
    let headers = vec![
        ("authorization".to_string(), "Bearer secret_token_123".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert_eq!(token, Some("secret_token_123".to_string()));
}

#[test]
fn test_token_extraction_api_key_header() {
    let headers = vec![
        ("X-Api-Key".to_string(), "api_key_456".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert_eq!(token, Some("api_key_456".to_string()));
}

#[test]
fn test_token_extraction_api_key_lowercase() {
    let headers = vec![
        ("x-api-key".to_string(), "api_key_789".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert_eq!(token, Some("api_key_789".to_string()));
}

#[test]
fn test_token_extraction_query_param() {
    let headers: Vec<(String, String)> = vec![];

    let token = extract_token_from_request(&headers, Some("token=query_token_abc"));
    assert_eq!(token, Some("query_token_abc".to_string()));
}

#[test]
fn test_token_extraction_query_param_with_other_params() {
    let headers: Vec<(String, String)> = vec![];

    let token = extract_token_from_request(&headers, Some("foo=bar&token=my_token&baz=qux"));
    assert_eq!(token, Some("my_token".to_string()));
}

#[test]
fn test_token_extraction_bearer_takes_priority() {
    // If both header and query param are present, header should be used first
    let headers = vec![
        ("Authorization".to_string(), "Bearer header_token".to_string()),
    ];

    let token = extract_token_from_request(&headers, Some("token=query_token"));
    assert_eq!(token, Some("header_token".to_string()));
}

#[test]
fn test_token_extraction_none_found() {
    let headers = vec![
        ("Content-Type".to_string(), "application/json".to_string()),
    ];

    let token = extract_token_from_request(&headers, Some("foo=bar"));
    assert_eq!(token, None);
}

#[test]
fn test_token_extraction_empty_bearer() {
    let headers = vec![
        ("Authorization".to_string(), "Bearer ".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert_eq!(token, Some("".to_string()));
}

#[test]
fn test_token_extraction_basic_auth_ignored() {
    // Basic auth should not be extracted as a token
    let headers = vec![
        ("Authorization".to_string(), "Basic dXNlcjpwYXNz".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert_eq!(token, None);
}

// ============================================================================
// TLS Configuration Tests
// ============================================================================

#[test]
fn test_tls_config_creation() {
    let config = TlsConfig::new("/path/to/cert.pem", "/path/to/key.pem");

    assert_eq!(config.cert_path, "/path/to/cert.pem");
    assert_eq!(config.key_path, "/path/to/key.pem");
}

#[test]
fn test_tls_config_with_different_paths() {
    let config = TlsConfig::new(
        "/etc/ssl/certs/server.crt",
        "/etc/ssl/private/server.key",
    );

    assert_eq!(config.cert_path, "/etc/ssl/certs/server.crt");
    assert_eq!(config.key_path, "/etc/ssl/private/server.key");
}

// ============================================================================
// Token File Tests
// ============================================================================

#[test]
fn test_token_file_single_token() {
    let (token_path, _temp_dir) = create_token_file(&["single_token"]).unwrap();

    let content = fs::read_to_string(&token_path).unwrap();
    assert!(content.contains("single_token"));
}

#[test]
fn test_token_file_multiple_tokens() {
    let (token_path, _temp_dir) = create_token_file(&[
        "token_1",
        "token_2",
        "token_3",
    ]).unwrap();

    let content = fs::read_to_string(&token_path).unwrap();
    assert!(content.contains("token_1"));
    assert!(content.contains("token_2"));
    assert!(content.contains("token_3"));
}

#[test]
fn test_token_file_loading() {
    let (token_path, _temp_dir) = create_token_file(&[
        "# Comment line",
        "valid_token_1",
        "",  // Empty line
        "valid_token_2",
        "  # Another comment",
    ]).unwrap();

    // Read and parse tokens (simulating load_tokens_from_file behavior)
    let content = fs::read_to_string(&token_path).unwrap();
    let tokens: HashSet<String> = content
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .map(|s| s.to_string())
        .collect();

    assert_eq!(tokens.len(), 2);
    assert!(tokens.contains("valid_token_1"));
    assert!(tokens.contains("valid_token_2"));
    assert!(!tokens.contains("# Comment line"));
}

// ============================================================================
// Certificate File Tests
// ============================================================================

#[test]
fn test_certificate_generation() {
    let result = generate_test_certificate();
    assert!(result.is_ok());

    let (cert_path, key_path, _temp_dir) = result.unwrap();

    // Verify files exist
    assert!(cert_path.exists());
    assert!(key_path.exists());

    // Verify cert contains PEM header
    let cert_content = fs::read_to_string(&cert_path).unwrap();
    assert!(cert_content.contains("-----BEGIN CERTIFICATE-----"));
    assert!(cert_content.contains("-----END CERTIFICATE-----"));

    // Verify key contains PEM header
    let key_content = fs::read_to_string(&key_path).unwrap();
    assert!(key_content.contains("-----BEGIN") && key_content.contains("PRIVATE KEY-----"));
}

// ============================================================================
// Integration Scenario Tests
// ============================================================================

#[test]
fn test_auth_flow_valid_token() {
    // Simulate a complete auth flow
    let config = AuthConfig::with_tokens(vec!["secret_production_token".to_string()]);
    let manager = AuthManager::new(config);

    // Client sends request with valid token
    let headers = vec![
        ("Authorization".to_string(), "Bearer secret_production_token".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert!(token.is_some());

    let is_valid = manager.validate_token(token.as_ref().unwrap());
    assert!(is_valid);
}

#[test]
fn test_auth_flow_invalid_token() {
    let config = AuthConfig::with_tokens(vec!["correct_token".to_string()]);
    let manager = AuthManager::new(config);

    // Client sends request with invalid token
    let headers = vec![
        ("Authorization".to_string(), "Bearer wrong_token".to_string()),
    ];

    let token = extract_token_from_request(&headers, None);
    assert!(token.is_some());

    let is_valid = manager.validate_token(token.as_ref().unwrap());
    assert!(!is_valid);
}

#[test]
fn test_auth_flow_missing_token() {
    let config = AuthConfig::with_tokens(vec!["expected_token".to_string()]);
    let manager = AuthManager::new(config);

    // Client sends request without token
    let headers: Vec<(String, String)> = vec![];

    let token = extract_token_from_request(&headers, None);
    assert!(token.is_none());

    // Should reject when no token provided but auth is enabled
    // In practice, the server would reject before calling validate_token
}

#[test]
fn test_tls_and_auth_combined() {
    // Test that TLS config and auth config can coexist
    let tls_config = TlsConfig::new("/path/to/cert.pem", "/path/to/key.pem");
    let auth_config = AuthConfig::with_tokens(vec!["secure_token".to_string()]);
    let auth_manager = AuthManager::new(auth_config);

    // Both should be configured
    assert!(!tls_config.cert_path.is_empty());
    assert!(auth_manager.is_enabled());

    // Auth should still work
    assert!(auth_manager.validate_token("secure_token"));
    assert!(!auth_manager.validate_token("insecure_token"));
}

#[test]
fn test_multiple_auth_methods() {
    let config = AuthConfig::with_tokens(vec![
        "bearer_token".to_string(),
        "api_key_token".to_string(),
        "query_token".to_string(),
    ]);
    let manager = AuthManager::new(config);

    // Test Bearer token
    let headers1 = vec![("Authorization".to_string(), "Bearer bearer_token".to_string())];
    let token1 = extract_token_from_request(&headers1, None);
    assert!(manager.validate_token(token1.as_ref().unwrap()));

    // Test API key
    let headers2 = vec![("X-Api-Key".to_string(), "api_key_token".to_string())];
    let token2 = extract_token_from_request(&headers2, None);
    assert!(manager.validate_token(token2.as_ref().unwrap()));

    // Test query param
    let headers3: Vec<(String, String)> = vec![];
    let token3 = extract_token_from_request(&headers3, Some("token=query_token"));
    assert!(manager.validate_token(token3.as_ref().unwrap()));
}

// ============================================================================
// Edge Cases
// ============================================================================

#[test]
fn test_token_with_special_characters() {
    let config = AuthConfig::with_tokens(vec![
        "token+with/special=chars".to_string(),
        "token-with_underscores".to_string(),
        "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyIn0.sig".to_string(), // JWT-like
    ]);
    let manager = AuthManager::new(config);

    assert!(manager.validate_token("token+with/special=chars"));
    assert!(manager.validate_token("token-with_underscores"));
    assert!(manager.validate_token("eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyIn0.sig"));
}

#[test]
fn test_very_long_token() {
    let long_token = "a".repeat(1000);
    let config = AuthConfig::with_tokens(vec![long_token.clone()]);
    let manager = AuthManager::new(config);

    assert!(manager.validate_token(&long_token));
}

#[test]
fn test_unicode_token() {
    let config = AuthConfig::with_tokens(vec![
        "token_with_√©mojis_üîê".to_string(),
        "Êó•Êú¨Ë™û„Éà„Éº„ÇØ„É≥".to_string(),
    ]);
    let manager = AuthManager::new(config);

    assert!(manager.validate_token("token_with_√©mojis_üîê"));
    assert!(manager.validate_token("Êó•Êú¨Ë™û„Éà„Éº„ÇØ„É≥"));
    assert!(!manager.validate_token("token_with_different_emoji_üîí"));
}

#[test]
fn test_whitespace_handling() {
    let config = AuthConfig::with_tokens(vec!["  trimmed_token  ".trim().to_string()]);
    let manager = AuthManager::new(config);

    assert!(manager.validate_token("trimmed_token"));
    assert!(!manager.validate_token("  trimmed_token  "));
}
